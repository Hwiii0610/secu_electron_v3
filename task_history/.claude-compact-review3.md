# Claude Compact Review

## 1. Primary Request

> "자동객체 탐지 수행후에, 프레임별로 탐지된 객체의 바울링박스가 붉은색으로 표시됨... 감지된 객채의 영역이 겹칠 경우, 사용자는 어떤 객체를 선택중인지 구분할 수가 없습니다. 따라서 마우스 커서가 해당 박스 영역에 호버중일 경우, 해당 박스의 색상이 주황색으로 출력되도록 기능을 추가"

사용자의 핵심 요청: 자동객체탐지 후 표시되는 붉은색 바울링박스에 **마우스 호버 시 주황색으로 색상 변경**하는 기능 추가. 객체 영역이 겹칠 때 사용자가 어떤 객체를 선택 중인지 시각적으로 구분할 수 있도록 개선.

## 2. Technical Concepts

- **프레임워크**: Vue.js 3 + Electron
- **파일**: `secuwatcher_electron/src/App.vue`
- **Canvas API**: HTML5 Canvas를 사용한 바울링박스 렌더링
- **이벤트 처리**: `onCanvasMouseMove` 이벤트 핸들러

## 3. Files & Code

### 수정 파일: `secuwatcher_electron/src/App.vue`

#### 3.1 데이터 속성 추가 (data())
```javascript
manualBiggestTrackId: '',
maskBiggestTrackId: '',
hoveredBoxId: null,  // 마우스 호버 중인 박스의 track_id 저장 (추가)
```

#### 3.2 마우스 호버 감지 메서드 추가
```javascript
// 마우스 위치에 있는 바울링 박스 확인
checkHoveredBox(e) {
  if (!this.$refs.videoPlayer || !this.$refs.maskingCanvas) return;
  
  const clickPoint = this.convertToOriginalCoordinates(e);
  const currentFrame = this.getCurrentFrameNormalized() + 1;
  
  // 겹치는 모든 박스 저장 { track_id, area }
  let overlappingBoxes = [];
  
  // 1) detectionResults에서 확인 (자동객체탐지 결과)
  const currentFrameBoxes = this.detectionResults.filter(
    item => item.frame === Math.floor(this.video.currentTime * this.frameRate)
  );
  for (const result of currentFrameBoxes) {
    if (result.bbox) {
      const coords = result.bbox.split(',').map(Number);
      if (coords.length === 4 && coords.every(num => !isNaN(num))) {
        const [x, y, w, h] = coords;
        if (clickPoint.x >= x && clickPoint.x <= x + w &&
            clickPoint.y >= y && clickPoint.y <= y + h) {
          overlappingBoxes.push({ track_id: result.track_id, area: w * h });
        }
      }
    }
  }
  
  // 2) maskingLogs에서 확인 (CSV 데이터)
  if (this.csvLoaded) {
    const logs = this.maskingLogs.filter(log => Number(log.frame) === currentFrame);
    for (const log of logs) {
      try {
        const bboxData = JSON.parse(log.bbox);
        // 사각형 형식 [x0, y0, x1, y1]
        if (Array.isArray(bboxData) && bboxData.length === 4 && !Array.isArray(bboxData[0])) {
          const [x0, y0, x1, y1] = bboxData;
          if (clickPoint.x >= x0 && clickPoint.x <= x1 &&
              clickPoint.y >= y0 && clickPoint.y <= y1) {
            overlappingBoxes.push({ track_id: log.track_id, area: (x1 - x0) * (y1 - y0) });
          }
        }
        // 다각형 형식은 바울링 박스로 체크
        else if (Array.isArray(bboxData) && bboxData.length >= 3 && Array.isArray(bboxData[0])) {
          const xs = bboxData.map(point => point[0]);
          const ys = bboxData.map(point => point[1]);
          const minX = Math.min(...xs), minY = Math.min(...ys);
          const maxX = Math.max(...xs), maxY = Math.max(...ys);
          if (clickPoint.x >= minX && clickPoint.x <= maxX &&
              clickPoint.y >= minY && clickPoint.y <= maxY) {
            overlappingBoxes.push({ track_id: log.track_id, area: (maxX - minX) * (maxY - minY) });
          }
        }
      } catch (error) { /* 파싱 오류 무시 */ }
    }
  }
  
  // 면적이 가장 작은 박스 선택 (낮은 박스 우선)
  let foundBoxId = null;
  if (overlappingBoxes.length > 0) {
    overlappingBoxes.sort((a, b) => a.area - b.area);
    foundBoxId = overlappingBoxes[0].track_id;
  }
  
  // 호버 상태 변경 시에만 다시 그리기
  if (this.hoveredBoxId !== foundBoxId) {
    this.hoveredBoxId = foundBoxId;
    this.drawBoundingBoxes();
  }
}
```

#### 3.3 onCanvasMouseMove에서 호출
```javascript
onCanvasMouseMove(e) {
  if (e.button !== 0) return;
  
  // 마우스 위치에 있는 박스 확인 (호버 효과용) - 추가
  this.checkHoveredBox(e);
  
  if (this.currentMode === 'manual') {
    // ... 기존 코드
  }
}
```

#### 3.4 색상 변경 로직 (drawDetectionBoxes)
```javascript
// 호버 상태에 따라 색상 변경
const isHovered = this.hoveredBoxId === result.track_id;
ctx.strokeStyle = isHovered ? 'orange' : 'red';
ctx.fillStyle = isHovered ? 'orange' : 'red';
```

#### 3.5 색상 변경 로직 (drawCSVMasks)
```javascript
const isHovered = this.hoveredBoxId === log.track_id;
ctx.strokeStyle = isHovered ? 'orange' : (log.object === 1 ? 'red' : 'blue');
ctx.fillStyle = isHovered ? 'orange' : (log.object === 1 ? 'red' : 'blue');
```

## 4. Errors & Fixes

발생한 에러: 없음

## 5. Problem Solving

### 문제 1: 객체 영역 겹침 시 선택 구분
**상황**: 1번 박스 낮에 2번 박스가 포함되어 있을 때, 어떤 객체를 선택 중인지 구분 불가

**해결**: 
- 모든 겹치는 박스를 배열에 저장 (`overlappingBoxes`)
- 면적 계산 후 정렬 (`sort((a, b) => a.area - b.area)`)
- **가장 작은 면적의 박스(낮은 박스) 우선 선택**

```
┌─────────────────────────┐
│                         │
│    ┌──────────┐         │
│    │          │         │  ← 마우스 위치 (두 박스 겹침)
│    │    ID:2  │         │
│    │ (주황색) │         │  ← 작은 면적 = 선택됨
│    └──────────┘         │
│          ID:1           │
│       (빨간색)          │  ← 큰 면적 = 선택되지 않음
└─────────────────────────┘
```

### 문제 2: 성능 최적화
**상황**: 매 프레임마다 캔버스를 다시 그리면 성능 저하

**해결**: 
```javascript
// 호버 상태 변경 시에만 다시 그리기
if (this.hoveredBoxId !== foundBoxId) {
  this.hoveredBoxId = foundBoxId;
  this.drawBoundingBoxes();
}
```

## 6. User Messages

### 초기 요청
> "현재프로젝트에서, 1.자동객체 탐지 수행후에, 프레임별로 탐지된 객체의 바울링박스가 붉은색으로 표시됨 2.붉은색 박스를 우클릭하면 지정객체/미지정객체 등의 옵션선택 메뉴가 출력됨. 위 와같은 상황에서, 감지된 객채의 영역이 겹칠 경우, 사용자는 어떤 객체를 선택중인지 구분할 수가 없습니다. 따라서 마우스 커서가 해당 박스 영역에 호버중일 경우, 해당 박스의 색상이 주황색으로 출력되도록 기능을 추가"

### 추가 질문
> "두개의 객체가 겹쳐진 상태에서, 1번 객채 박스내부에 2번객채 박스가 포함되어 있을 경우엔 어떻게 처리되나요?"

### 최종 요청
> "작업내용 요약 스킬 수행"

## 7. Pending Tasks

- [ ] 기능 테스트 (영상 로드 및 자동객체탐지 후 확인)
- [ ] 다각형 마스킹 데이터에도 동일하게 적용되는지 확인
- [ ] 성능 테스트 (프레임 드롭 없는지 확인)

## 8. Current Work

**완료된 작업**: 
- 파일: `secuwatcher_electron/src/App.vue`
- 기능: 마우스 호버 시 바울링박스 주황색 표시
- 겹쳐진 박스 처리: 면적 기준 작은 박스 우선 선택

**수정된 메서드**:
- `data()`: `hoveredBoxId` 추가
- `onCanvasMouseMove()`: `checkHoveredBox()` 호출 추가
- `checkHoveredBox()`: 새 메서드 (마우스 위치 박스 감지)
- `drawDetectionBoxes()`: 색상 변경 로직 추가
- `drawCSVMasks()`: 색상 변경 로직 추가

## 9. Optional Next Step

> "작업내용 요약 스킬 수행"

다음 작업: 사용자가 요청한 작업이 모두 완료되었으므로, 추가 요청이 있을 때까지 대기하거나 다음 작업을 진행합니다.

---

## 10. Additional Work (2026-02-10 이후)

### 10.1 CSV 구조 분석 및 리뷰

**요청**: 지정객체/미지정객체 선택 시 저장되는 CSV 구조 파악 및 리뷰

**분석 결과**:
```
frame,track_id,bbox,score,class_id,type,object
```

| 컬럼 | 설명 | 값 |
|------|------|-----|
| frame | 프레임 번호 | 0, 1, 2, 3... |
| track_id | 추적 ID | "1_1", "2_1" (타입_순번) |
| bbox | 바울링박스 | "[x, y, w, h]" |
| score | 신뢰도 | 0.0 ~ 1.0 |
| class_id | 클래스 ID | 정수 |
| type | 탐지 유형 | 1=자동, 2=선택, 3=수동, 4=영역마스킹 |
| object | 지정/미지정 | 1=지정(빨강), 2=미지정(파랑) |

**토글 로직**: `object: 1 ↔ 2` (우클릭 메뉴 "지정객체/미지정객체")

---

### 10.2 CSV 저장 버그 수정

**문제**: `mode='a'` (append) 사용으로 기존 데이터 누적 및 프레임 0번 빈 값 문제

**수정 파일**: `secuwatcher_python/detector.py`

**변경 내용**:
```python
# 변경 전 (line 237-249)
df.to_csv(output_file, mode='a', header=False, ...)

# 변경 후
df.to_csv(output_file, mode='w', header=True, ...)
```

**적용 함수**:
- `autodetector()` - 자동 객체 탐지
- `selectdetector()` - 선택 객체 탐지

**결과**: 매 탐지 시 새로운 CSV 파일 생성, 중복 데이터 제거

---

### 10.3 총 프레임 수 계산 버그 수정

**문제**: 
- Electron: `duration × fps` → 반올림 오차 → **4058** 표시
- 실제/OpenCV: **4057** 프레임
- 1프레임 차이 발생

**원인**: 이론적 계산(`135.266s × 30fps = 4057.99...`)의 반올림 오차

**수정 파일**: `secuwatcher_electron/src/main.js`

**변경 내용** (line 1123-1129):
```javascript
// 총 프레임 수 계산
// 우선순위: nb_frames (메타데이터) > duration * frameRate (계산값)
if (videoStream.nb_frames && parseInt(videoStream.nb_frames) > 0) {
  info.totalFrames = parseInt(videoStream.nb_frames);  // 4057 (정확한 값)
} else if (info.duration && info.frameRate) {
  info.totalFrames = Math.round(info.duration * info.frameRate);  // 폴백
}
```

**결과**: 파일 추가 시 정확한 **4057** 프레임 표시 (OpenCV와 일치)

---
*Generated: 2026-02-10*
*Skill: claude-compact*
